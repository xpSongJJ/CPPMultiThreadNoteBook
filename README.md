# C++多线程学习笔记
该笔记根据B站课程记录，笔记的记录顺序随着课程的顺序，代码示例较课程上的有点改动。课程地址：https://www.bilibili.com/video/BV1Yb411L7ak/?p=6&spm_id_from=pageDriver&vd_source=ec46083ee7ebee9588ca7ef33741b702

## 创建线程
### 主线程与子线程的区别
- 主线程：从main()函数开始，每个程序必须具备一个主线程。

- 子线程：用户自己创建的线程。 

### 创建线程方法 
假设`fun()`为可调用对象。
- `std::thread t(fun)`：  创建线程t，该线程以可调用对象fun为入口，线程在此刻就开始执行。  
- `t.join()`：  阻塞主线程，待该子线程执行完毕后，与主线程汇合。  
- `t.detach()`： 该方法执行后，该子线程主主线程剥离，不再与主线程关联，此时该子线程会驻留在后台，由c++运行时库接管，待执行完后，再由运行时库清理相关资源，即守护线程。值传递，主线程结束后，对象被释放，子线程运行的是对象的拷贝。  
- `t.joinable()`： 判断是否可以成功使用join()或detach()，返回true或false。

## `detach()`方法问题分析 
示例： 
```cpp
thread t(fun, var);
t.detach();
``` 
 调用detach()方法后，子线程t将会独立于主线程运行，主线程结束后，在主线程内创建的资源将会被销毁，假设var是传递的主线程内的资源，子线程是如何处理的。这要依据资源传递方式看待：
 - var是值传递：资源会被子线程复制一份来处理。 
 - var是引用传递：资源依然会被复制一份。如果要实现真正的引用传递，可使用`thread t(fun, std::ref(var))`。  
 - var是指针传递：资源被销毁，子线程出问题。  
**注意**：传递参数时要尽量避免隐式转换，隐式转换需要时间，有可能出现主线程结束，资源还未被转换就被销毁，导致丢失资源。解决方法可以是在传递参数时显式转换，生成临时对象。

## 多线程数据共享
### 多线程创建
示例： 
```cpp
…
void fun(int x){
	cout << "这是线程x" << endl;
}
…
vector<thread> threads;
for(int i=0; i<10; ++i){
	threads.push_back(thread(fun, i));
}
for(auto it=threads.begin(); it!=threads.end(); ++it){
	it->join();
}
```
多个线程的执行顺序与创建先后无关，与操作系统的调度机制有关。所以示例代码输出会比较乱。 

### 数据共享分析
- 只读数据：安全稳定，不需要什么处理手段。
- 有读有写：具体情况具体分析。 
案例：[点这里](code/test1.cpp)  
案例表述的是两个子线程共同操作一个共享队列（list），一个线程负责写，一个线程负责拿。两个线程共同运行时，就会出现一些问题。（该案例好像没出现什么致命问题）

## 互斥量（锁）与死锁 
为保护共享资源（独占共享资源），在使用共享资源前为其加锁，使用过后再解锁。但多个线程操作多个共享资源时就有可能造成死锁现象。 
### 互斥量的用法 
1. `lock()与unlock()`:  
```cpp
...
std::mutex my_mutex; // 声明互斥量对象
...
my_mutex.lock(); // 加锁
// 需要保护的操作
...
my_mutex.lock(); // 解锁
...
```
注意：`lock()`和`unlock()`必须成对出现，所以在条件语句使用`unolck()`时要考虑到条件不成立的情况。 
示例：[点这里](code\test2.cpp)  
该示例是对**test1**示例的两个子线程添加互斥锁，使双线程操作共享数据时不会冲突。

2. `lock_guard`:  
```cpp
...
std::mutex my_mutex // 声明互斥量对象
...
std::lock_guard<std::mutex> guard(my_mutex);
... // 受保护操作
```
`lock_guard`是类模板，可以解决使用`lock()`时，容易遗忘`unlock()`的问题。`lock_guard`之于`lock()`类似于智能指针之于指针，利用了C++的RAII机制，资源获取即初始化（构造函数），离开作用域就销毁资源（虚构函数）。可以使用`{}`收缩作用域。其缺点是不如`lock() & unlock()`灵活。示例：[点这里](code\test3.cpp)  

### 死锁  
死锁至少需要两个互斥量才能产生。死锁只有满足这4个条件才能发生：互斥条件、持有并等待、不可剥夺条件和环路条件。  
- 互斥条件：多个线程不能同时使用同一个资源； 
- 持有并等待：线程在等待其它资源的同时不会释放持有的资源；
- 不可剥夺条件：线程持有的资源在未使用完以前不能被强制剥夺；
- 环路条件：线程获取资源的顺序形成了环路；  
示例：[点这里](code\test4.cpp)  
该示例实际中很难用到，拿两把锁（金锁银锁）来锁同一个共享数据，当出现线程1用金锁锁定共享数据，这是线程2又用银锁锁定了共享数据，谁都没办法打开对方的锁，导致死锁。  
### 死锁的解决办法
死锁需要同时满足4个条件才能发生，破坏其中一个就可以解决，常用的方法是破坏环路。在`test4`中，让两个线程上两把锁的顺序一致就可以避免死锁。这也算是破环环路，但不直观，比较直观的是2个线程2个共享资源：线程1持有A资源正获取B资源，线程2持有B资源正获取A资源，解决该死锁办法是2个线程对2个资源的访问顺序一致，就不会出现环路，从而不会产生死锁。  

### `std::lock()函数模板` 
`std::lock()`一次锁住2个及以上互斥量，因为它对多个互斥量加锁的顺序是一致的，从而避免了因为锁顺序导致的死锁问题。可以结合`lock_guard`(需要传入`std::adopt_lock`参数)实现不用再手动`unlock()`。示例：[点这里](code\test5.cpp)  
视频up主给的建议：谨慎使用该方法，建议一个一个锁。

## `unique_lock`详解  
`unique_lock`是类模板，它是通用互斥包装器，允许延迟锁定、锁定的有时限尝试、递归锁定、所有权转移和与条件变量一同使用。  
### `unique_lock`取代`lock_guard`  
`unique_lock`比`lock_guard`灵活（提供了更多的功能），但效率较差，占用内存较多。构造对象时可额外传入的参数及其含义：  
- `std::adopt_lock`：和`lock_guard`传入的该参数功能相同，表示之前的互斥量已经加锁，`unique_lock`构造对象时不再加锁。  
- `std::try_to_lock`：构造对象时尝试用`mutex`的`lock()`去锁定这个`mutex`，如果没有锁定成功，就立即返回，不会阻塞在那里，这样可以利用该线程去做其它事情。示例：[点这里](code\test6.cpp)   
这个示例不是很完美，有闲心的话可以优化优化。  
- `std::defer_lock`：不获得互斥量的所用权，即推迟加锁。其前提也是不自己`lock()`，针对这个对象（其它`unique_lock`对象也适用）就会有一些成员函数可调用：
	> 1. `lock()`：手动加锁，但可以自动释放。
	> 2. `unlock()`：灵活解锁或提前解锁，使锁更加灵活，优化锁的粒度。示例：[点这里](code\test7.cpp)  
	> 3. `try_lock()`：尝试给互斥量加锁，拿到锁就返回true，否则返回false。 
	> 4. `release()`：打断互斥量与`*this`的关联，返回指向该互斥量的指针，若互斥量还未被解锁，则需要接管者负责互斥量的解锁。示例：[点这里](code\test8.cpp)  
> **粒度**：锁住的代码量被称为粒度，粒度用粗细来衡量。锁住的代码少时，粒度较细，执行效率一般较高。锁住代码量多时，粒度较粗，执行效率一般较低。需要保持合适的粒度。  
### `unique_lock`所有权传递  
`unique_lock`独占一个互斥量的所有权，和`unique_ptr`比较类似。所以`unique_lock`只能转移互斥量的所有权，不能复制互斥量的所有权。所有权转移的方法： 
```cpp
... 
std::unique_lock<mutex> ul1(my_mutex);
std::unique_lock<mutex> ul2(std::move(my_mutex)); // 将my_mutex所有权由ul1转移至ul2
... 
``` 
## 单例设计模式共享数据分析、解决
设计模式是代码的一些写法，这样的写法使程序更加灵活，维护起来更加方便。但这样的代码对于不了解设计模式的人来说晦涩难懂。设计模式出现的初衷是用来管理大型项目，这样时后期的维护更加方便。  
### 单例设计模式 
单例设计模式是指某些特殊的类（单例类）只能创建一个对象。一个简单的单例类：[点这里](code\test9.cpp)  
该类使用的技巧有：私有化构造函数、静态成员指针变量存储对象、嵌套类实现析构。  
### 共享数据分析、解决 
单例类建议在主线程（子线程之前）完成对象的创建与初始化。当需要在子线程中创建单例类时，可能面临GetInstance()成员函数互斥的问题。  
```cpp
... 
static MyCAS *GetInstance(){ 
	if(m_instance == nullptr){ // 线程可能在这里切换，导致多个线程通过这个条件，就会构造多个对象
		m_instance = new MyCAS();
		static GarbageRec gc;  // 静态类对象在程序退出时析构
	}
	return m_instance;
}  
... 
``` 
解决办法：
```cpp 
... 
std::mutex resource_mutex;  // 在类外
... 
static MyCAS *GetInstance(){ 
	if(m_instance == nullptr){  // 双重检查，收紧条件，为了提高效率，这是比较推荐的方法
		std::unique_lock<std::mutex> ul(resource_mutex);  // 自动加锁
		if(m_instance == nullptr){
			m_instance = new MyCAS();
			static GarbageRec gc;  // 静态类对象在程序退出时析构
		}
	}
	return m_instance;
... 
```   
另一种解决方法是使用`std::call_once()`。
### `std::call_once()` 
即使多线程调用可调用对象，依然只执行一次。具备互斥量的功能，但效率比直接使用互斥量高。  
`void call_once(std::once_flag& flag, Callable&& f, Args&&... args)`  
- `flag`：通过这个标记来决定可调用对象`f`是否执行，调用`call_once()`成功后，这个标记就会被标记为已调用状态，如果后续再次调用`call_once()`,就会检查`flag`状态，来决定是否执行可调用对象`f`。  
- `f`：可调用对象。
- `args`：向可调用对象`f`传递的变量。  
示例：[点这里](code\test10.cpp)  
该示例是上面问题的另一个解决办法，这里利用`std::call_once()`只执行一次的特性，来确保多个线程同时进行时只能创建一个对象。需要声明一个全局变量`std::once_flag  g_flag`传入`std::call_once()`用来判断可调用对象`CreateInstance()`是否已被某个线程执行，这个可调用对象定义为私有成员函数，实现了对象的创建。  
> 注意：依然建议在主线程中创建对象

## 条件变量`condition_variable`   
回顾一下前面的双线程例子：有两个子线程，线程A负责往队列（共享数据）写数据，线程B负责从队列取数据，线程B需要不停地访问队列（通过循环实现），判断队列里是否存在数据，如果存在就取出来，否则继续循环判断，这样写显得有些笨拙，不停地加锁解锁，而且很有限制性。现在可以利用条件变量进行优化。  
条件变量的成员函数有： 
-  `void wait(std::unique_lock<std::mutex>& lock)`：传入的参数是`unique_lock`对象，原子地解锁`lock`，阻塞当前线程，并将它添加到于`*this`上等待的线程列表。线程将在执行`notify_all()`或`notify_one()`时被解除阻塞。解阻塞时，无关乎原因，`lock`再次锁定且`wait`退出。
- `void wait(std::unique_lock<std::mutex>& lock, Predicate pred)`：第二个参数是一个[谓词](https://www.apiref.com/cpp-zh/cpp/named_req/Predicate.html)，定义自己的等待条件。这个重载函数相当于：  
> ```cpp
> while(!pred){
> 	wait(lock);
> }  
> // 当wait()不含有第二个参数时，被唤醒的wait()直接通过
> // 含有第二个参数时，则还需判断谓词条件
> ``` 
- `void notify_one()`：唤醒`wait()`，只能通知一个线程。示例：[点这里](code\test11.cpp)   
- `notify_all()`唤醒全部等待于`*this`的线程。


